# 800-1200

## implementation

### [1856A-800](https://codeforces.com/problemset/problem/1856/A)

#### 题面翻译

给出一个**正整数**数组 $\{a_n | a_i \in Z^+\}$，定义操作：

- $\forall i \in D, a_i = max(0, a_i - 1)$

现在给你一个数组 $a$，请你回答进行多少次上述操作后 $a$ 可以变成一个非递减的数组。

#### 题解

显然，每次操作都会使 $a_i - 1$，直到 $a_i == 0$。我们考虑两数相邻的情况：

- $a_i <= a_{i + 1}$，无需操作。
- $a_i > a_{i + 1}$，则至少需要操作 $a_i$ 次，直到 $a_i == a_{i + 1} == 0$。

```cpp
// Author: CastorYe
// Time: 2023-09-04 10:36:11
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
typedef long double ld;

const int N = 100;
int ls[N];

void solve() {
    int n; cin >> n;
    for (int i = 0; i < n; i ++) cin >> ls[i];

    int res = 0;
    for (int i = 0; i < n - 1; i ++) {
        // 找到最大的操作次数
        if (ls[i] > ls[i + 1]) res = max(res, ls[i]);
    }

    cout << res << endl;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    int T; cin >> T;
    while (T -- ) solve();
    return 0;
}
```

### [1856B-900](https://codeforces.com/problemset/problem/1856/B)

#### 题面翻译

给出一个**正整数**数组 $\{a_n | a_i \in Z^+\}$，现在定义**好数组** $\{b_n | b_i \in Z^+\}$ 为：

- $a_i \ne b_i, \forall i \in [0, n]$ 
- $\displaystyle \sum_{i = 1}^n a_i = \sum_{i = 1}^n = b_i$

现在给出一个数组 $a$，请你判断其是否存在好数组 $b$。

#### 题解

可以发现，对于 $a$ 中的数：

- `1`只能增加，不能减少。
- 非`1`数可以增加，也可以减少。

显然，要存在**好数组**，应该让非`1`数减少，同时让`1`增加。因此，我们考虑极端情况：每个非`1`数都减少到`1`，若能满足所有的`1`都增加，则存在**好数组**。

```cpp
// Author: CastorYe
// Time: 2023-09-04 10:53:53
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
typedef long double ld;

void solve() {
    int n; cin >> n;
    ll sum = 0;

    for (int i = 0; i < n; i ++) {
        ll x; cin >> x; 
        // x - 1 非1数减少到1
        // - (x == 1) 让1增加
        sum += x - 1 - (x == 1);
    }
	// 如果此时 sum >= 0 则说明可以满足条件
    cout << (sum >= 0 and n > 1 ? "YES" : "NO") << endl;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    int T; cin >> T;
    while (T -- ) solve();
    return 0;
}
```

### [1850E-1100](https://codeforces.com/contest/1850/problem/E)

#### 题面翻译

有 $n$ 个正方形，其边长为 $s_i + 2w$，现在知道总面积 $c$ 和所有正方形的边长 $s_i$，求满足条件的 $w$

#### 题解1：二分

显然：
$$
c = \sum_{i = 1}^n (s_i + 2 * w)^2
$$
使用**二分查找**来确定 $w$ 的值，需要注意的是可能爆`long long`，所以需要在二分中进行`for`循环，或者对上式进行预处理。

```cpp
// Author: CastorYe
// Time: 2023-09-04 12:19:39
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
typedef long double ld;

const int N = 2e5 + 10;
ll ls[N];

void solve() {
    ll n, c; cin >> n >> c;
    for (int i = 0; i < n; i ++) cin >> ls[i];

    ll l = 1, r = 1e9 + 1;
    while (l <= r) {
        ll sum = 0, mid = (l + r) >> 1;

        for (int i = 0; i < n; i ++) {
            sum += (ls[i] + 2 * mid) * (ls[i] + 2 * mid);
            if (sum > c) break;
        }

        if (sum == c) {
            cout << mid << endl; return;
        }
        else if (sum > c) r = mid - 1;
        else l = mid + 1;
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    int T; cin >> T;
    while (T -- ) solve();
    return 0;
}
```

#### 题解2：模拟

直接使用`sqrt()`函数来求解：
$$
c = \sum_{i = 1}^n s_i^2 + 4 w \sum_{i = 1}^n s_i + 4nw^2
$$
可以用二次函数的求解公式来求 $w$：
$$
ax^2 + bx + c = 0 \Rightarrow x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}
$$

$$
w = \frac{\sqrt{\displaystyle 16 (\sum_{i = 1}^n s_i)^2 - 16n(c - \sum_{i = 1}^n s_i^2)} - 4 \displaystyle \sum_{i = 1}^n s_i}{8n}
$$

```cpp
// Author: CastorYe
// Time: 2023-09-04 12:19:39
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
typedef long double ld;

const int N = 2e5 + 10;
ll ls[N];

void solve() {
    int n; ld c; cin >> n >> c;
    ld t = 0;

    for (int i = 0; i < n; i ++) {
        cin >> ls[i];
        c -= ls[i] * ls[i], t += 4 * ls[i];
    }

    printf(
        "%.0LF\n", (sqrt(t * t + c * n * 16) - t) / 8 / n
    );
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    int T; cin >> T;
    while (T -- ) solve();
    return 0;
}
```

### [1850D-900](https://codeforces.com/problemset/problem/1850/D)

#### 题面翻译

给出一个数组，可以操作任意次：

- 删除一些数（可以不删）。
- 将数组随意排序。

现在有一个整数 $k$，求要满足数组中相邻元素差值小于等于 $k$，所需要删除的最少元素数量。

#### 题解

先将数组排序，则数组必定成以下规则：
$$
\{a_1, a_2, \cdots, a_{n1} || b_1, b_2, \cdots, b_{n2} || \cdots \}
$$
因此我们可以用一个`栈`来维护满足要求的子数组，并记录每段子数组的长度的最大值。

```cpp
// Author: CastorYe
// Time: 2023-09-04 15:22:02
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
typedef long double ld;

const int N = 2e5 + 10;
int ls[N];

void solve() {
    int n, k; cin >> n >> k;
    for (int i = 0; i < n; i ++) cin >> ls[i];

    sort(ls, ls + n);

    stack<int> stk; int res = 0;
    for (int i = 0; i < n; i ++) {
        if (!stk.empty() and abs(stk.top() - ls[i]) > k) {
            res = max(res, (int)stk.size());
            while (!stk.empty()) stk.pop();
        }

        stk.push(ls[i]);
    }

    if (!stk.empty()) res = max(res, (int)stk.size());
    cout << n - res << endl;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    int T; cin >> T;
    while (T -- ) solve();
    return 0;
}
```

### [1850C-800](https://codeforces.com/problemset/problem/1850/C)

#### 题面翻译

有一个 $8 \times 8$ 的点阵，其中存在一个竖着的单词，请你输出这个单词。

#### 题解

```cpp
// Author: CastorYe
// Time: 2023-09-04 16:51:24
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
typedef long double ld;

void solve() {
    for (int i = 0; i < 8; i ++) {
        for (int j = 0; j < 8; j ++) {
            // 直接模拟即可
            char c; cin >> c;
            if (c != '.') cout << c;
        }
    }
    cout << endl;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    int T; cin >> T;
    while (T -- ) solve();
    return 0;
}
```

### [1850B-800](https://codeforces.com/problemset/problem/1850/B)

#### 题面翻译

有 $n$ 个玩家，每个玩家有 $x$ 个单词，其价值为 $y$。

游戏规则为 $x \le 10$ 的前提下，$y$ 最大的那个玩家获胜，请求出第几个玩家会胜出。

#### 题解

```cpp
// Author: CastorYe
// Time: 2023-09-04 21:40:25
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
typedef long double ld;

void solve() {
    int n; cin >> n;
    int idx = 0, res = 0;

    for (int i = 1; i <= n; i ++) {
        int x, y; cin >> x >> y;
        if (x <= 10 and res < y) {
            res = y;
            idx = i;
        }
    }

    cout << idx << endl;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    int T; cin >> T;
    while (T -- ) solve();
    return 0;
}
```

### [1850A-800](https://codeforces.com/problemset/problem/1850/A)

#### 题面翻译

给出三个数，返回其中是否存在两数之和大于等于 $10$。

#### 题解

```cpp
// Author: CastorYe
// Time: 2023-09-04 21:37:07
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
typedef long double ld;

void solve() {
    int a, b, c; cin >> a >> b >> c;
    if (a + b >= 10 or a + c >= 10 or b + c >= 10) cout << "YES" << endl;
    else cout << "NO" << endl;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    int T; cin >> T;
    while (T -- ) solve();
    return 0;
}
```

### [1849-A](https://codeforces.com/problemset/problem/1849/A)

#### 题面翻译

一个三明治必须按照以下结构：

- 面包，芝士/培根，面包，芝士/培根，面包，……，芝士/培根，面包

现在有 $x$ 片面包，$y$ 片芝士，$z$ 片培根，请求出面包的最大厚度。

#### 题解

```cpp
// Author: CastorYe
// Time: 2023-09-04 22:51:04
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
typedef long double ld;

void solve() {
    int x, y, z; cin >> x >> y >> z;
    
    cout << min(2 * x - 1, 2 * (y + z) + 1) << endl;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    int T; cin >> T;
    while (T -- ) solve();
    return 0;
}
```

